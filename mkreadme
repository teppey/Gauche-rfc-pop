#! /home/teppey/opt/bin/gosh
; vim:set fileencoding=utf-8 ft=scheme:

(use file.util)
(use gauche.process)

(define *base-dir* (expand-path "~/work/Gauche-rfc-pop3"))
(define *readme-skel* (build-path *base-dir* "README.skel"))
(define *readme-en* (build-path *base-dir* "README"))
(define *readme-jp* (build-path *base-dir* "README.ja"))
(define *texinfo* (build-path *base-dir* "doc/rfc_pop3.texi"))

(define (en&jp)
  (let ((en-out (open-output-string))
        (jp-out (open-output-string)))
    (define (%read-line)
      (let1 line (read-line)
        (cond ((eof-object? line) line)
              ((#/^@(clindex|mdindex|node|section)/ line)
               (%read-line))
              (else line))))
    (define (common line)
      (cond ((eof-object? line))
            ((#/^@c EN/ line)
             (en (%read-line)))
            ((#/^@c JP/ line)
             (jp (%read-line)))
            (else
              (dolist (p (list en-out jp-out))
                (display line p)
                (newline p))
              (common (%read-line)))))
    (define (jp line)
      (cond ((eof-object? line))
            ((#/^@c COMMON/ line)
              (common (%read-line)))
            ((#/^@c EN/ line)
             (en (%read-line)))
            (else
              (display line jp-out)
              (newline jp-out)
              (jp (%read-line)))))
    (define (en line)
      (cond ((eof-object? line))
            ((#/^@c COMMON/ line)
              (common (%read-line)))
            ((#/^@c JP/ line)
             (jp (%read-line)))
            (else
              (display line en-out)
              (newline en-out)
              (en (%read-line)))))

    (common (%read-line))
    (values (get-output-string en-out)
            (get-output-string jp-out))))

(define (main args)
  (receive (en-texi jp-texi)
    (with-input-from-file *texinfo* en&jp)
    (let ((en-plain (texi->plain en-texi))
          (jp-plain (texi->plain jp-texi)))
      (receive (en-readme-skel jp-readme-skel)
        (with-input-from-file *readme-skel* en&jp)
        (dolist (p `((,en-plain ,en-readme-skel ,*readme-en*)
                     (,jp-plain ,jp-readme-skel ,*readme-jp*)))
          (with-output-to-file (caddr p)
            (lambda ()
              (display (regexp-replace #/@Reference@/ (cadr p) (car p)))))))))
  0)

(define (texi->plain str)
  (let1 pc (run-process '("makeinfo" "--plaintext") :input :pipe :output :pipe :error "/dev/null")
    (display str (process-input pc))
    (close-output-port (process-input pc))
    (begin0 (port->string (process-output pc))
      (process-wait pc))))
